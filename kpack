#!/usr/bin/python3

from argparse import ArgumentParser
from re import match
from re import search
from os import path
from copy import deepcopy

from kpackea import *
from shapegeo import *
from items import *
from logger import Logger

import matplotlib.pyplot as plt





class kPack:

	'''
		This class implements the kPack program
	'''

	def __init__(self,eaParams,eaAlgo,shapeGeo,logger):

		# Object file to read the details of the objects
		self.objFile=str()

		# EA algorithm parameters
		self.eaParams=eaParams

		# Dictionary of all the objects
		self.objects=dict()

		# Shape Geometery library handler
		self.shapeGeo=shapeGeo

		# Logger library handler
		self.logger=logger

		# EA algorithm handler
		self.eaAlgo=eaAlgo

		# Convergence of the algorithm after specific iterations
		self.convIter=10

		# Best fitness value of each iteration is called the convergence's fitness
		self.convFitness=int()



		# Object file statements' regexes
		self.objFileReg = {
		'CONTAINER_DEF':'\s*container\s*:\s*',

		'OBJECT_DEF':'\s*objects\s*:\s*',

		'CIRCLE_DEF': '\s*(([1-9][0-9]*)\s*,)?\s*(circle)\s*:\s*r\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*\,\s*v\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*\,\s*w\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',

		'SQUARE_DEF': '\s*(([1-9][0-9]*)\s*,)?\s*(square)\s*:\s*a\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*\,\s*v\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*\,\s*w\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',

		'RTI_DEF': '\s*(([1-9][0-9]*)\s*,)?\s*(rti)\s*:\s*a\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*\,\s*v\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*\,\s*w\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',


		# TODO ELLIPSE

		}



		# Log messages of the kPack program
		self.logMessages = {
		'OBJ_FILE_NOT_SPECIFIED': 'No Object File Has Been Specified',

		'OBJ_FILE_NOT_FOUND': 'Object File Not Found',

		'OBJ_FILE_MULTI_CONTAINER_SEG_DEF': 'Multiple Definition Of Container Segment',

		'OBJ_FILE_MULTI_OBJECTS_SEG_DEF': 'Multiple Definition Of Objects Segment',

		'OBJ_FILE_CONTAINER_MULTI_OBJECTS_DEF': 'Multiple Definition Of Objects In Container Segment',

		'OBJ_FILE_OBJECTS_SEG_NO_OBJ': 'Objects Segment Cannot Be Empty',

		'OBJ_FILE_CONTAINER_SEG_NO_OBJ': 'Container Segment Cannot Be Empty',

		'OBJ_FILE_NO_CONTAINER_SEG_DEF': 'Container Segment Missing',

		'OBJ_FILE_NO_OBJECTS_SEG_DEF': 'Objects Segment Missing',

		'OBJ_FiLE_OBJECT_DEFINITION_ERR': 'Object Definition Error'

		}



	def read_arguement_params(self):
		'''
			This function implements the command line argument reader
		'''

		parser = ArgumentParser(description='kPack Help')

		parser.add_argument('-f','--file',  type=str, nargs=1,help='Specify A Report File Name')


		args = parser.parse_args()

		if args.file:

			self.objFile = args.file[0]

			if not path.exists(self.objFile):
				self.logger.log_message(self.logMessages['OBJ_FILE_NOT_FOUND'],'ERR')
				exit(1)

		else:
			self.logger.log_message(self.logMessages['OBJ_FILE_NOT_SPECIFIED'],'ERR')
			exit(1)


	def read_obj_file(self):
		'''
			This function reads the objects file and extract the objects
		'''
		fhandle=open(self.objFile)
		fileLines=fhandle.readlines()
		fhandle.close()


		# To handle multiple definition of container segement and
		# objects segment
		containerDef=0
		objectsDef=0

		# To handle object definition in each segment. Container segment
		# should handle only 1 object for the sake of this project. The 
		# objects segement should contain at least one object.
		containerObjCnt=0
		objectsObjCnt=0

		# Handling the segment
		currentSegment=str()


		# Objects code. This code will be incremented for each new
		# object.
		objCode=1


		# New object
		newItem=None

		# New object Count
		objCount=0


		for lineNum,line in enumerate(fileLines):

			line=line.strip()

			# Line number starts from zero, to handle this, we increment it 
			# to adjust it to start from one.
			lineNum+=1

			if line:

				if line.startswith('#'):
					continue


				if match(self.objFileReg['CONTAINER_DEF'],line):

					# Check for multiple definition of container segment
					if containerDef:
						self.logger.log_message(self.logMessages['OBJ_FILE_MULTI_CONTAINER_SEG_DEF']+str(lineNum),'ERR')
						exit(1)

					# Setting the definition status to 1
					containerDef=1

					# Setting the segment
					currentSegment='Container'


					# Check whether the objects segment has been defined before, and if it has,
					# does it contain at least one object or not.
					if objectsDef and (objectsObjCnt==0):
						self.logger.log_message(self.logMessages['OBJ_FILE_OBJECTS_SEG_NO_OBJ']+str(lineNum),'ERR')
						exit(1)

					continue


				elif match(self.objFileReg['OBJECT_DEF'],line):

					# Check for multiple definition of objects segment
					if objectsDef:
						self.logger.log_message(self.logMessages['OBJ_FILE_MULTI_OBJECTS_SEG_DEF']+str(lineNum),'ERR')
						exit(1)

					# Setting the definition status to 1
					objectsDef=1


					# Setting the segment
					currentSegment='Objects'



					# Check whether the objects segment has been defined before, and if it has,
					# does it contain at least one object or not.
					if containerDef and (containerObjCnt==0):
						self.logger.log_message(self.logMessages['OBJ_FILE_CONTAINER_SEG_NO_OBJ']+str(lineNum),'ERR')
						exit(1)

					continue


				elif match(self.objFileReg['CIRCLE_DEF'],line):


					circleRadius = float( search('\s*r\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )
					circleValue= float( search('\s*v\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )
					circleWeight= float( search('\s*w\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )


					# The portion that declares the object count
					cntPart= search('\s*(([1-9][0-9]*)\s*,)?\s*(circle)\s*',line).group(0)
						
					objCount=1

					if ',' in cntPart:
						objCount= int (cntPart.split(',')[0].strip())

				
					# Create the object 
					newItem=Item()
					newItemParams=CircleParams()
					newItemParams.set_radius(circleRadius)


					newItem.set_item_type('circle')
					newItem.set_item_value(circleValue)
					newItem.set_item_weight(circleWeight)

					newItem.set_item_param(newItemParams)
					newItem.set_item_area()


				elif match(self.objFileReg['SQUARE_DEF'],line):

					squareSide = float( search('\s*a\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )
					squareValue= float( search('\s*v\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )
					squareWeight= float( search('\s*w\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )


					# The portion that declares the object count
					cntPart= search('\s*(([1-9][0-9]*)\s*,)?\s*(square)\s*',line).group(0)
						
					objCount=1

					if ',' in cntPart:
						objCount= int (cntPart.split(',')[0].strip())

				
					# Create the object 
					newItem=Item()
					newItemParams=SquareParams()
					newItemParams.set_side(squareSide)


					newItem.set_item_type('square')
					newItem.set_item_value(squareValue)
					newItem.set_item_weight(squareWeight)

					newItem.set_item_param(newItemParams)
					newItem.set_item_area()

				elif match(self.objFileReg['RTI_DEF'],line):

					rtiSide = float( search('\s*a\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )
					rtiValue= float( search('\s*v\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )
					rtiWeight= float( search('\s*w\s*=\s*([+-]?([0-9]*[.])?[0-9]+)\s*',line).group(0).split("=")[1].strip() )


					# The portion that declares the object count
					cntPart= search('\s*(([1-9][0-9]*)\s*,)?\s*(rti)\s*',line).group(0)
						
					objCount=1

					if ',' in cntPart:
						objCount= int (cntPart.split(',')[0].strip())

				
					# Create the object 
					newItem=Item()
					newItemParams=RtiParams()
					newItemParams.set_side(rtiSide)


					newItem.set_item_type('rti')
					newItem.set_item_value(rtiValue)
					newItem.set_item_weight(rtiWeight)

					newItem.set_item_param(newItemParams)
					newItem.set_item_area()


				else:
					self.logger.log_message(self.logMessages['OBJ_FiLE_OBJECT_DEFINITION_ERR']+str(lineNum),'ERR')
					exit(1)


				# Adding the objects

				# Check the segment declaration

				if currentSegment=='Container':

					if containerObjCnt!=0:
						self.logger.log_message(self.logMessages['OBJ_FILE_CONTAINER_MULTI_OBJECTS_DEF']+str(lineNum),'ERR')
						exit(1)

					# Check for the object count
					if objCount!=1:
						self.logger.log_message(self.logMessages['OBJ_FILE_CONTAINER_MULTI_OBJECTS_DEF']+str(lineNum),'ERR')
						exit(1)

				
					# Adding the new item to the dictionary of the 
					# objects. However, since this is container, it would
					# be added as the first object with code equals 0.

					self.objects[0]=newItem

					# Set the object count to 1 for the container segment
					containerObjCnt=1

				else:

					for i in range(objCount):


						# Adding the object to the list
						self.objects[objCode]=deepcopy(newItem)

						# Incrementing the object code
						objCode+=1


						# Incrementing the objects segment's object count
						objectsObjCnt+=1


		
		if 	containerDef==0:
			self.logger.log_message(self.logMessages['OBJ_FILE_NO_CONTAINER_SEG_DEF']+str(lineNum),'ERR')
			exit(1)

		if 	objectsDef==0:
			self.logger.log_message(self.logMessages['OBJ_FILE_NO_OBJECTS_SEG_DEF']+str(lineNum),'ERR')
			exit(1)

		if containerObjCnt==0:
			self.logger.log_message(self.logMessages['OBJ_FILE_CONTAINER_SEG_NO_OBJ']+str(lineNum),'ERR')
			exit(1)

		if objectsObjCnt==0:
			self.logger.log_message(self.logMessages['OBJ_FILE_OBJECTS_SEG_NO_OBJ']+str(lineNum),'ERR')
			exit(1)


	def run_ea_computation(self):
		'''
			This function runs the EA algorithm on the objects
		'''

		# Filter the objects
		self.objects=self.eaAlgo.initial_filtering(self.objects)


		# Parameters of the container
		containerObjParams=self.objects[0]

		# Container center point coordinates
		containerCpX,containerCpY=containerObjParams.get_item_center_point()

		# Creating the object of the container based on its parameters
		containerObj=None


		if containerObjParams.get_item_type()=='circle':
			containerObj=self.shapeGeo.create_circle(centerX=containerCpX,centerY=containerCpY,radius=containerObjParams.get_item_param().get_radius())

		elif containerObjParams.get_item_type()=='square':
			containerObj=self.shapeGeo.create_square(centerX=containerCpX,centerY=containerCpY,side=containerObjParams.get_item_param().get_side(),rotation=containerObjParams.get_item_rotation_angle())







		# Generating initial population
		population=self.eaAlgo.generate_initial_population(self.objects,containerObj,containerObjParams)

		# sol=population[0]

		# for obj in sol[0]:
		# 	print(obj[2].get_item_type())
		# 	exit(0)


		# exit(0)
		self.eaAlgo.calculate_fitness_value(population,self.objects)


		fittestSolutions=self.eaAlgo.get_fittest_solution(population)

		
		self.draw_solution(containerObj,[fittestSolutions[0]])

		
		self.logger.log_message("Start Running The EA Algorithm For 300 Cycles","INF")



		# Convergence Counter
		convCnt=self.convIter
		self.convFitness = self.eaAlgo.get_best_fitness_of_population(population)

		for i in range(300):


			# Perform selection from the population
			selectedPopulation = self.eaAlgo.select_from_population(population)			

			# Performing the combination of parents
			parentsNotMated,newOffsprings=self.eaAlgo.mate_population(selectedPopulation,containerObj,containerObjParams,self.objects)

		
			# Performing offspring mutation
			self.eaAlgo.perform_mutation(containerObj,containerObjParams,self.objects,newOffsprings)


			# The new population
			population=[*parentsNotMated,*newOffsprings]


			self.eaAlgo.calculate_fitness_value(population,self.objects)

			bestFitnessOfTheIteration = self.eaAlgo.get_best_fitness_of_population(population)

			# Reset the convergence properties
			if bestFitnessOfTheIteration != self.convFitness:
				convCnt=self.convIter

			else:
				convCnt-=1
				
				if convCnt == 0:
					break


		# Return the fittest solution(s) from the population
		fittestSolutions=self.eaAlgo.get_fittest_solution(population)


		if len(fittestSolutions)>1:

			self.logger.log_message("Multiple Solutions Have Been Found ({0} Solutions)".format(len(fittestSolutions)),"INF")



		return containerObj,fittestSolutions


	def draw_solution(self,containerObj,solutions):

		'''
			This function draws the solutions
		'''



		for solution in solutions:

			print(solution[4])

			x, y = containerObj.exterior.xy

			plt.plot(x,y,c="black")

			for shape in solution[0]:

				x, y = shape[1].exterior.xy

				plt.plot(x,y,c="black")

			plt.show()


		



logger=Logger()
eaParams=EvolAlgoParams()
shapeGeo=ShapeGeo()
eaAlgo=KpackEA(logger,eaParams,shapeGeo)



obj=kPack(eaParams,eaAlgo,shapeGeo,logger)
obj.read_arguement_params()
obj.read_obj_file()


# for k,v in obj.objects.items():
# 	print(k,v)
containerObj,res=obj.run_ea_computation()
obj.draw_solution(containerObj,res)

# for k,v in obj.objects.items():
# 	print(k,v)





